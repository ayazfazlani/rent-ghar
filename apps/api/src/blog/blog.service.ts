import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { Blog } from '../../../../packages/db/src/schemas/blog.schema';
import { Model, isValidObjectId } from 'mongoose';
import { InjectModel } from '@nestjs/mongoose';
import { BlogDocument } from '../../../../packages/db/src/schemas/blog.schema';
import { Category } from '../../../../packages/db/src/schemas/category.schema';
import { CreateBlogDto } from '../../../../packages/dtos/blog/createblog.dto';
import { UpdateBlogDto } from '../../../../packages/dtos/blog/updateblog.dto';

@Injectable()
export class BlogService {
    constructor(
        @InjectModel(Blog.name) private blogModel: Model<BlogDocument>,
        @InjectModel(Category.name) private categoryModel: Model<any>
    ){}


    async findPublishedBlogs(): Promise<BlogDocument[]> {
        return await this.blogModel.find({ status: 'published' }).exec();
    }
    async findActiveBlogs(): Promise<BlogDocument[]> {
        return await this.blogModel.find({ status: 'active' }).exec();
    }
    async createBlog(createBlogDto: CreateBlogDto): Promise<BlogDocument> {
        // Map categoryId to categories array if provided
        const blogData: any = {
            title: createBlogDto.title,
            content: createBlogDto.content,
            excerpt: createBlogDto.excerpt,
            tags: createBlogDto.tags || [],
            featuredImage: createBlogDto.featuredImage,
            status: createBlogDto.status || 'draft',
            metaTitle: createBlogDto.metaTitle,
            metaDescription: createBlogDto.metaDescription,
            canonicalUrl: createBlogDto.canonicalUrl,
        };

        // Handle slug - if not provided, it will be auto-generated by schema pre-save hook
        if (createBlogDto.slug) {
            blogData.slug = createBlogDto.slug.toLowerCase().trim();
        }

        // Handle author - set if provided, otherwise will need to be set from auth context
        if (createBlogDto.author) {
            if (!isValidObjectId(createBlogDto.author)) {
                throw new BadRequestException('Invalid author ID');
            }
            blogData.author = createBlogDto.author;
        }

        // Handle categories - support both categoryId (single) and categories (array)
        if (createBlogDto.categories && createBlogDto.categories.length > 0) {
            // Validate all category IDs and verify they exist in Category table
            for (const categoryId of createBlogDto.categories) {
                if (!isValidObjectId(categoryId)) {
                    throw new BadRequestException(`Invalid category ID: ${categoryId}`);
                }
                // Verify category exists in Category table
                const category = await this.categoryModel.findById(categoryId).exec();
                if (!category) {
                    throw new NotFoundException(`Category not found: ${categoryId}`);
                }
            }
            blogData.categories = createBlogDto.categories;
        } else if (createBlogDto.categoryId) {
            // Backward compatibility: handle single categoryId
            if (!isValidObjectId(createBlogDto.categoryId)) {
                throw new BadRequestException('Invalid category ID');
            }
            // Verify category exists in Category table
            const category = await this.categoryModel.findById(createBlogDto.categoryId).exec();
            if (!category) {
                throw new NotFoundException('Category not found');
            }
            blogData.categories = [createBlogDto.categoryId];
        }

        const blog = await this.blogModel.create(blogData);
        return blog;
    }

    async findAllBlogs(status?: string): Promise<BlogDocument[]> {
        const query: any = {};
        if (status) {
            query.status = status;
        }
        return await this.blogModel
            .find(query)
            .populate('author', 'name email')
            .populate('categories', 'name slug')
            .sort({ createdAt: -1 })
            .exec();
    }

    async findBlogById(id: string): Promise<BlogDocument> {
        if (!isValidObjectId(id)) {
            throw new BadRequestException('Invalid blog ID');
        }
        const blog = await this.blogModel
            .findById(id)
            .populate('author', 'name email')
            .populate('categories', 'name slug')
            .exec();
        if (!blog) {
            throw new NotFoundException('Blog not found');
        }
        return blog;
    }

    async findBlogBySlug(slug: string): Promise<BlogDocument> {
        // Only return published blogs for public access
        // Note: NestJS @Param decorator automatically decodes URL-encoded slugs
        // So slug is already decoded when it reaches this method
        
        const blog = await this.blogModel
            .findOne({ 
                slug: slug, // Slug is already decoded by NestJS
                status: 'published' // Only return published blogs for public access
            })
            .populate('author', 'name email')
            .populate('categories', 'name slug')
            .exec();
            
        if (!blog) {
            throw new NotFoundException(`Blog not found with slug: ${slug}`);
        }
        
        // Increment views for analytics
        blog.views += 1;
        await blog.save();
        
        return blog;
    }

    async updateBlog(id: string, updateBlogDto: UpdateBlogDto): Promise<BlogDocument> {
        if (!isValidObjectId(id)) {
            throw new BadRequestException('Invalid blog ID');
        }

        const updateData: any = { ...updateBlogDto };

        // Handle slug - normalize if provided
        if (updateBlogDto.slug) {
            updateData.slug = updateBlogDto.slug.toLowerCase().trim();
        }

        // Handle categories array if provided
        if (updateBlogDto.categories) {
            // Validate all category IDs and verify they exist in Category table
            for (const categoryId of updateBlogDto.categories) {
                if (!isValidObjectId(categoryId)) {
                    throw new BadRequestException(`Invalid category ID: ${categoryId}`);
                }
                // Verify category exists in Category table
                const category = await this.categoryModel.findById(categoryId).exec();
                if (!category) {
                    throw new NotFoundException(`Category not found: ${categoryId}`);
                }
            }
        }

        const blog = await this.blogModel
            .findByIdAndUpdate(id, updateData, { new: true, runValidators: true })
            .populate('author', 'name email')
            .populate('categories', 'name slug')
            .exec();

        if (!blog) {
            throw new NotFoundException('Blog not found');
        }
        return blog;
    }

    async deleteBlog(id: string): Promise<void> {
        if (!isValidObjectId(id)) {
            throw new BadRequestException('Invalid blog ID');
        }
        const blog = await this.blogModel.findByIdAndDelete(id).exec();
        if (!blog) {
            throw new NotFoundException('Blog not found');
        }
    }

    async incrementViews(id: string): Promise<void> {
        if (!isValidObjectId(id)) {
            throw new BadRequestException('Invalid blog ID');
        }
        await this.blogModel.findByIdAndUpdate(id, { $inc: { views: 1 } }).exec();
    }
}
